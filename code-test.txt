import cv2
import torch
import matplotlib.pyplot as plt
from IPython.display import display, clear_output
from transformers import pipeline
from datetime import datetime
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from twilio.rest import Client


# ------------------- YOLOv5 Model Loading -------------------

model = torch.hub.load('ultralytics/yolov5', 'custom', path='path/to/yolo_model.pt', source='local')

# Define threat classes (replace with your specific model's classes)
threat_classes = ['knife', 'gun', 'weapon']


# ------------------- Threat Detection -------------------

def detect_threats(frame):
    """Detect threats in the current frame using YOLOv5."""
    results = model(frame)
    df = results.pandas().xyxy[0]  # Bounding boxes and class probabilities as pandas dataframe
    threats_detected = df[df['name'].isin(threat_classes)]  # Filter for threats
    return threats_detected, results


# ------------------- Incident Report Generation -------------------

def generate_incident_report(threats_detected):
    """Generates a report using Hugging Face transformers based on detected threats."""
    if not threats_detected.empty:
        # Extract threat details
        threat_details = []
        for _, threat in threats_detected.iterrows():
            threat_details.append(f"{threat['name']} detected with {threat['confidence']*100:.2f}% confidence.")
        
        # Create a prompt for the report generation
        prompt = f"Incident Report: {len(threats_detected)} threats detected. " + " ".join(threat_details)
    else:
        prompt = "Incident Report: No threats detected."

    # Load Hugging Face pipeline for text generation
    report_generator = pipeline('text-generation', model='gpt2')  # Using GPT-2 model
    report = report_generator(prompt, max_length=200, num_return_sequences=1)[0]['generated_text']
    
    # Timestamp for the report
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    return f"Incident Report (Generated at {timestamp}):\n\n{report}"


# ------------------- Email Notification -------------------

def send_email_alert(receiver_email, subject, body, smtp_server, smtp_port, smtp_user, smtp_password):
    """Function to send email notifications"""
    try:
        msg = MIMEMultipart()
        msg['From'] = smtp_user
        msg['To'] = receiver_email
        msg['Subject'] = subject
        
        msg.attach(MIMEText(body, 'plain'))

        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        server.login(smtp_user, smtp_password)
        text = msg.as_string()
        server.sendmail(smtp_user, receiver_email, text)
        server.quit()
        print(f"Email sent to {receiver_email}")
    except Exception as e:
        print(f"Failed to send email: {e}")


# ------------------- SMS Notification (Twilio) -------------------

def send_sms_alert(to_number, body, twilio_sid, twilio_token, twilio_phone_number):
    """Function to send SMS alerts"""
    try:
        client = Client(twilio_sid, twilio_token)
        message = client.messages.create(
            body=body,
            from_=twilio_phone_number,
            to=to_number
        )
        print(f"SMS sent to {to_number}")
    except Exception as e:
        print(f"Failed to send SMS: {e}")


# ------------------- RTSP Video Stream with Threat Detection -------------------

def capture_rtsp_stream_with_threat_detection(rtsp_url, email_receiver, phone_number):
    """Capture RTSP stream, perform threat detection, generate reports, and send real-time alerts."""
    capture = cv2.VideoCapture(rtsp_url)

    if not capture.isOpened():
        print('Cannot open RTSP stream.')
        return

    print('Successfully connected to the RTSP stream.')

    while True:
        ret, frame = capture.read()

        if not ret:
            print('Failed to grab frame')
            break

        # Convert frame from BGR (OpenCV format) to RGB (required for YOLOv5)
        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

        # Detect threats
        threats_detected, _ = detect_threats(frame_rgb)

        # If threats detected, generate report and send alerts
        if not threats_detected.empty:
            print("Threats detected!")

            # Generate incident report
            report = generate_incident_report(threats_detected)

            # Display report
            print(report)

            # Send email and SMS alerts
            send_email_alert(
                receiver_email=email_receiver,
                subject="Urgent: Threat Detected!",
                body=report,
                smtp_server='smtp.example.com',
                smtp_port=587,
                smtp_user='your_email@example.com',
                smtp_password='your_password'
            )

            send_sms_alert(
                to_number=phone_number,
                body="Urgent: Threat detected! Check your email for details.",
                twilio_sid='your_twilio_sid',
                twilio_token='your_twilio_token',
                twilio_phone_number='your_twilio_phone_number'
            )

        # Display the video feed inline in Jupyter Notebook
        plt.imshow(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))
        plt.axis('off')
        display(plt.gcf())
        clear_output(wait=True)

        # Stop the video if 'q' is pressed
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    capture.release()
    cv2.destroyAllWindows()


# ------------------- Main Function -------------------

if __name__ == "__main__":
    # Example usage with dummy data
    rtsp_url = 'your_rtsp_stream_url'
    email_receiver = 'receiver_email@example.com'
    phone_number = '+1234567890'

    capture_rtsp_stream_with_threat_detection(rtsp_url, email_receiver, phone_number)
